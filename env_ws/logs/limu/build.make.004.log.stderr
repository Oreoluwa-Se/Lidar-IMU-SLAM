[01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/src/sensors/lidar/helpers/voxel_hash_map.cpp:[m[K In lambda function:
[01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/src/sensors/lidar/helpers/voxel_hash_map.cpp:181:70:[m[K [01;31m[Kerror: [m[Kpassing â€˜[01m[Kconst lidar::VoxelBlock[m[Kâ€™ as â€˜[01m[Kthis[m[Kâ€™ argument discards qualifiers [[01;31m[K-fpermissive[m[K]
  181 |                         it->second.remove_points(origin, max_distance[01;31m[K)[m[K;
      |                                                                      [01;31m[K^[m[K
In file included from [01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/include/limu/sensors/lidar/helpers/voxel_hash_map.hpp:6[m[K,
                 from [01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/src/sensors/lidar/helpers/voxel_hash_map.cpp:1[m[K:
[01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/include/limu/sensors/lidar/helpers/voxel_block.hpp:45:14:[m[K [01;36m[Knote: [m[K  in call to â€˜[01m[Kvoid lidar::VoxelBlock::remove_points(const Vec3d&, double)[m[Kâ€™
   45 |         void [01;36m[Kremove_points[m[K(const utils::Vec3d &point, double distance);
      |              [01;36m[K^~~~~~~~~~~~~[m[K
[01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/src/sensors/lidar/helpers/voxel_hash_map.cpp:183:46:[m[K [01;31m[Kerror: [m[Kpassing â€˜[01m[Kconst lidar::VoxelBlock[m[Kâ€™ as â€˜[01m[Kthis[m[Kâ€™ argument discards qualifiers [[01;31m[K-fpermissive[m[K]
  183 |                         if (it->second.empty([01;31m[K)[m[K)
      |                                              [01;31m[K^[m[K
In file included from [01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/include/limu/sensors/lidar/helpers/voxel_hash_map.hpp:6[m[K,
                 from [01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/src/sensors/lidar/helpers/voxel_hash_map.cpp:1[m[K:
[01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/include/limu/sensors/lidar/helpers/voxel_block.hpp:47:21:[m[K [01;36m[Knote: [m[K  in call to â€˜[01m[Kbool lidar::VoxelBlock::empty()[m[Kâ€™
   47 |         inline bool [01;36m[Kempty[m[K()
      |                     [01;36m[K^~~~~[m[K
In file included from [01m[K/usr/include/tbb/concurrent_vector.h:27[m[K,
                 from [01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/src/sensors/lidar/helpers/voxel_hash_map.cpp:2[m[K:
/usr/include/tbb/blocked_range.h: In instantiation of â€˜[01m[Kbool tbb::blocked_range<Value>::empty() const [with Value = tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>][m[Kâ€™:
[01m[K/usr/include/tbb/parallel_for.h:84:17:[m[K   required from â€˜[01m[Kstatic void tbb::interface9::internal::start_for<Range, Body, Partitioner>::run(const Range&, const Body&, Partitioner&) [with Range = tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >; Body = lidar::VoxelHashMap::remove_points_from_far(const Vec3d&)::<lambda(tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >&)>; Partitioner = const tbb::auto_partitioner][m[Kâ€™
[01m[K/usr/include/tbb/parallel_for.h:201:73:[m[K   required from â€˜[01m[Kvoid tbb::parallel_for(const Range&, const Body&) [with Range = tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >; Body = lidar::VoxelHashMap::remove_points_from_far(const Vec3d&)::<lambda(tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >&)>][m[Kâ€™
[01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/src/sensors/lidar/helpers/voxel_hash_map.cpp:190:14:[m[K   required from here
[01m[K/usr/include/tbb/blocked_range.h:89:42:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator<[m[Kâ€™ (operand types are â€˜[01m[Kconst tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>[m[Kâ€™ and â€˜[01m[Kconst tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>[m[Kâ€™)
   89 |     bool empty() const {return ![01;31m[K(my_begin<my_end)[m[K;}
      |                                 [01;31m[K~~~~~~~~~^~~~~~~~[m[K
In file included from [01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/src/sensors/lidar/helpers/voxel_hash_map.cpp:2[m[K:
[01m[K/usr/include/tbb/concurrent_vector.h:1367:13:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class T, class A1, class A2> bool tbb::operator<(const tbb::concurrent_vector<T, A1>&, const tbb::concurrent_vector<T, A2>&)[m[Kâ€™
 1367 | inline bool [01;36m[Koperator[m[K<(const concurrent_vector<T, A1> &a, const concurrent_vector<T, A2> &b)
      |             [01;36m[K^~~~~~~~[m[K
[01m[K/usr/include/tbb/concurrent_vector.h:1367:13:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
In file included from [01m[K/usr/include/tbb/concurrent_vector.h:27[m[K,
                 from [01m[K/mnt/c/wslShared/robotics/lidar/lidar-imu-slam/env_ws/src/limu/src/sensors/lidar/helpers/voxel_hash_map.cpp:2[m[K:
[01m[K/usr/include/tbb/blocked_range.h:89:42:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kconst tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>[m[Kâ€™ is not derived from â€˜[01m[Kconst tbb::concurrent_vector<T, A1>[m[Kâ€™
   89 |     bool empty() const {return ![01;36m[K(my_begin<my_end)[m[K;}
      |                                 [01;36m[K~~~~~~~~~^~~~~~~~[m[K
/usr/include/tbb/blocked_range.h: In instantiation of â€˜[01m[Ktbb::blocked_range<Value>::size_type tbb::blocked_range<Value>::size() const [with Value = tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>; tbb::blocked_range<Value>::size_type = long unsigned int][m[Kâ€™:
[01m[K/usr/include/tbb/blocked_range.h:93:52:[m[K   required from â€˜[01m[Kbool tbb::blocked_range<Value>::is_divisible() const [with Value = tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>][m[Kâ€™
[01m[K/usr/include/tbb/partitioner.h:248:9:[m[K   required from â€˜[01m[Kvoid tbb::interface9::internal::partition_type_base<Partition>::execute(StartType&, Range&) [with StartType = tbb::interface9::internal::start_for<tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >, lidar::VoxelHashMap::remove_points_from_far(const Vec3d&)::<lambda(tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >&)>, const tbb::auto_partitioner>; Range = tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >; Partition = tbb::interface9::internal::auto_partition_type][m[Kâ€™
[01m[K/usr/include/tbb/parallel_for.h:142:9:[m[K   required from â€˜[01m[Ktbb::task* tbb::interface9::internal::start_for<Range, Body, Partitioner>::execute() [with Range = tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >; Body = lidar::VoxelHashMap::remove_points_from_far(const Vec3d&)::<lambda(tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >&)>; Partitioner = const tbb::auto_partitioner][m[Kâ€™
[01m[K/usr/include/tbb/parallel_for.h:140:11:[m[K   required from here
[01m[K/usr/include/tbb/blocked_range.h:78:32:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator-[m[Kâ€™ (operand types are â€˜[01m[Kconst tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>[m[Kâ€™ and â€˜[01m[Kconst tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>[m[Kâ€™)
   78 |         return size_type([01;31m[Kmy_end-my_begin[m[K);
      |                          [01;31m[K~~~~~~^~~~~~~~~[m[K
/usr/include/tbb/blocked_range.h: In instantiation of â€˜[01m[Kstatic Value tbb::blocked_range<Value>::do_split(tbb::blocked_range<Value>&, tbb::split) [with Value = tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>][m[Kâ€™:
[01m[K/usr/include/tbb/blocked_range.h:100:26:[m[K   required from â€˜[01m[Ktbb::blocked_range<Value>::blocked_range(tbb::blocked_range<Value>&, tbb::split) [with Value = tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>][m[Kâ€™
[01m[K/usr/include/tbb/parallel_for.h:67:57:[m[K   required from â€˜[01m[Ktbb::interface9::internal::start_for<Range, Body, Partitioner>::start_for(tbb::interface9::internal::start_for<Range, Body, Partitioner>&, typename Partitioner::split_type&) [with Range = tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >; Body = lidar::VoxelHashMap::remove_points_from_far(const Vec3d&)::<lambda(tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >&)>; Partitioner = const tbb::auto_partitioner; typename Partitioner::split_type = tbb::split][m[Kâ€™
[01m[K/usr/include/tbb/parallel_for.h:121:21:[m[K   required from â€˜[01m[Kvoid tbb::interface9::internal::start_for<Range, Body, Partitioner>::offer_work(typename Partitioner::split_type&) [with Range = tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >; Body = lidar::VoxelHashMap::remove_points_from_far(const Vec3d&)::<lambda(tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >&)>; Partitioner = const tbb::auto_partitioner; typename Partitioner::split_type = tbb::split][m[Kâ€™
[01m[K/usr/include/tbb/partitioner.h:252:21:[m[K   required from â€˜[01m[Kvoid tbb::interface9::internal::partition_type_base<Partition>::execute(StartType&, Range&) [with StartType = tbb::interface9::internal::start_for<tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >, lidar::VoxelHashMap::remove_points_from_far(const Vec3d&)::<lambda(tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >&)>, const tbb::auto_partitioner>; Range = tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >; Partition = tbb::interface9::internal::auto_partition_type][m[Kâ€™
[01m[K/usr/include/tbb/parallel_for.h:142:9:[m[K   required from â€˜[01m[Ktbb::task* tbb::interface9::internal::start_for<Range, Body, Partitioner>::execute() [with Range = tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >; Body = lidar::VoxelHashMap::remove_points_from_far(const Vec3d&)::<lambda(tbb::blocked_range<tsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false> >&)>; Partitioner = const tbb::auto_partitioner][m[Kâ€™
[01m[K/usr/include/tbb/parallel_for.h:140:11:[m[K   required from here
[01m[K/usr/include/tbb/blocked_range.h:134:47:[m[K [01;31m[Kerror: [m[Kno match for â€˜[01m[Koperator-[m[Kâ€™ (operand types are â€˜[01m[Ktsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>[m[Kâ€™ and â€˜[01m[Ktsl::detail_robin_hash::robin_hash<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock>, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::KeySelect, tsl::robin_map<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock, utils::VoxelHash>::ValueSelect, utils::VoxelHash, std::equal_to<Eigen::Matrix<int, 3, 1> >, std::allocator<std::pair<Eigen::Matrix<int, 3, 1>, lidar::VoxelBlock> >, false, tsl::rh::power_of_two_growth_policy<2> >::robin_iterator<false>[m[Kâ€™)
  134 |         Value middle = r.my_begin + [01;31m[K(r.my_end - r.my_begin)[m[K / 2u;
      |                                     [01;31m[K~~~~~~~~~~^~~~~~~~~~~~~[m[K
make[2]: *** [CMakeFiles/limu.dir/build.make:154: CMakeFiles/limu.dir/src/sensors/lidar/helpers/voxel_hash_map.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:225: CMakeFiles/limu.dir/all] Error 2
make: *** [Makefile:141: all] Error 2
